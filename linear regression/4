import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns;sns.set()
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import PolynomialFeatures
import random



def gradiant_decent(weight, arrX, arrY):
    gWeight = [0, 0, 0]
    n = len(arrY)
    for i in range(n):
        x = arrX[i]
        y = arrY[i]
        gWeight[2] += -(2 / n) * x[1] ** 2 * (y - (weight[0] + weight[1] * x[1] + weight[2] * x[2]))
        gWeight[1] += -(2/n) * x[1] * (y - (weight[0] + weight[1] * x[1] + weight[2] * x[2]))
        gWeight[0] += -(2 / n) * (y - (weight[0] + weight[1] * x[1] + weight[2] * x[2]))
    newWeight = [weight[0], weight[1], weight[2]]
    newWeight[0] = newWeight[0] - gWeight[0] * 0.001
    newWeight[1] = newWeight[1] - gWeight[1] * 0.001
    newWeight[1] = newWeight[1] - gWeight[1] * 0.001

    return newWeight


"""def cost(weight, bias, data, y):
    cost = 0
    i = 0
    for a in data:
        cost += (y[i] - (a * weight + bias)) ** 2
        i += 1
    return cost"""

costs = []
weight = [0, 0, 0]
bias = 0
epochs = 30
x = np.load('TA_Xhouses.npy')
y = np.load('TA_yprice.npy')

poly = PolynomialFeatures(degree=2)
xpoly = poly.fit_transform(x)
model = LinearRegression(fit_intercept = True)
model.fit(xpoly, y)
xfit = np.linspace(0,15, 100)[:, np.newaxis]
xfitPoly = PolynomialFeatures.transform(poly, xfit)
yfit = model.predict(xfitPoly)
new_x = []
for num in x:
    new_x.append([1, num, num **2])
for i in range(epochs):
    batchX = []
    batchY = []
    numbers = set()
    while len(numbers) < 5:
        num = random.randint(0, 13)
        numbers.add(num)
    for num in numbers:
        batchY.append(y[num])
        batchX.append(x[num])
    weight = gradiant_decent(weight, new_x, batchY)

plt.scatter(x, y)
plt.plot(xfit, yfit)
plt.show()

plt.clf()
plt.scatter(x, y)
plt.plot(list(range(14, 22)), [weight[0] + weight[1] * x + weight[2] * x ** 2 for x in range(4, 12)])
plt.show()

